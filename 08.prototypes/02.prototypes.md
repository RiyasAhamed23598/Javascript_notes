
# Prototype

- Every single function including constructor functions has a shared space called `prototype`.
- We can access this space using function.prototype which is an object.
- We can add shared utilities to this space.
- Only functions have access to this shared space or property called prototype.
- All the instances of constructor functions, will have access to this shared space.
- So, we ensure no code duplication is done and memory is also used efficiently.

``` javascript
function fun() {}
console.log(fun.prototype); // {}

function constructorFunction() {
  this.name = "saksham";
  this.age = 20;
  this.id = 1;
}

constructorFunction.prototype.utility1 = function () {};
constructorFunction.prototype.utility2 = function () {};

const me = new constructorFunction();
const you = new constructorFunction();
console.log(me) // constructorFunction {name: 'saksham', age: 20, id: 1}
```

## __ proto __

- Okay, we have a shared space but how do the instances get access to this shared spaces?
- Every single variable in Javascript primitives or reference has access to a special property `__ proto __`.
- This special property simply refers to a shared space decalred using function.prototype.
- All the instances created have this `__ proto __` which refers to function.prototype which is an object.
- Since the shared space is also an object so it will also have this special property `__ proto __`.

``` javascript
const num = 4;
const name = "John";
const isActive = true;
const object = {};
const arr = [];

console.log(num.__proto__); // Number {0, toExponential: ƒ, toFixed: ƒ, toPrecision: ƒ, toString: ƒ, …} Number.prototype
console.log(name.__proto__); // String {'', anchor: ƒ, at: ƒ, big: ƒ, blink: ƒ, …} String.prototype
console.log(isActive.__proto__); // Boolean {false, toString: ƒ, valueOf: ƒ} Boolean.prototype
console.log(object.__proto__); // Object.prototype
console.log(arr.__proto__); // Array.prototype


```

## Prototype chain

- Whenever we search for a property in an object, it first tries to find in the object itself. If not found, it goes to it's proto then it's proto and so on till it reaches `null`.

``` javascript
const human = { kind: "human" };

const me = Object.create(human);
me.age = 27;

const you = Object.create(me);

console.log(you.age);
console.log(you.kind);

```

- First we create an object `human`. Since it is a type, it will have `__ proto __` which refers to `Object.prototype`.
- Then we create `me` object which has a property `age` and it's `__ proto __` is refrerring to the `human` object.
- Then we create `you` object whose `__ proto __` refers to the `me` object.
- So, when we search for `age` in `you`, it is first searched in `you` object. Since, It's not there it is then searched in it's proto which refers to the `me` object. `Me` object has `age` property, so our search finishes.
- When we search for `kind`, it is first searched in `you` object. Then it's `proto` which is the `me` object. Since we still don't find it we keep going up the chain and look in `human` object.

# Closures

- A function is able to retain access to its outer (enclosing) scope, even after that scope has finished executing.

``` javascript
function a() {
  let grandpa = "grandpa";

  return function b() {
    let parent = "parent";

    return function c() {
      let son = "son";
      console.log(`${grandpa} > ${parent} > ${son}`);
    };
  };
}

a()()();

```

- Both `a` and `b` have finished executing and are removed from call stack.
- So ideally, the scope should have been garbage colllected as a function has finished execution.
- But because of closures, we are able to access outer scope even after it is destroyed.

## Exercise

``` javascript
function callMeMaybe() {
  setTimeout(function () {
    console.log(callMe);
  }, 4000);
  const callMe = "Hi! I am now here!";
}

callMeMaybe(); // Hi! I am now here!

```
- JS is lexically scoped. Depending upon where our function is written JS decides the scope even before code execution starts.
- When `callMeMaybe` is invoked, a new execution context is created and hoisting occours.
- So, `callMe` gets initialized to `undefined`.
- Code execution starts.
- `setTimeout` is sent to web apis and `callMe` gets assigned the value of `Hi! I am now here!` and the function finishes executing.
- After the timer is complete, the inner callback function runs, and even though the outer function is no longer in the stack, it still remembers it's value because of closures.
